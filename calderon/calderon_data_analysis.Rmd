---
title: "Embryogenesis continuum -- Calderon et al. 2022"
subtitle: "Playing with Seurat data"
author: "TS O'Leary"
date: 'September 23, 2022'
output:
  rmarkdown::html_document:
    theme: sandstone
    toc: true
    toc_float: true
---

```{r setup, include = FALSE}
# Don't show echos, warnings, or messages
knitr::opts_chunk$set(warning = FALSE, 
                      message = FALSE,
                      comment = "")
```

# **scRNA data**

## Load packages and data

```{r}
# Load packages
require(tidyverse)
require(Seurat)
require(SingleR)

# Load data
dat <- readRDS(here::here("calderon/data/main.Rds"))
```

## Data structure of Seurat object

```{r}
# Class
class(dat)

# Structure of data
str(dat)

# Peak at the data
head(dat)

# Print dimensions
# Rows = genes; columns = cells
dim(dat)
```

## Metadata per cell
```{r}
# Metadata of each cell
glimpse(dat@meta.data)

# Number of cells per experiment
dat@meta.data %>% 
  dplyr::count(orig.ident)

# Number of cells per time window
dat@meta.data %>% 
  dplyr::count(time)

# Number of cells in each time window
dat@meta.data %>%
  dplyr::count(seurat_clusters)
```

## Visualize clusters

```{r}
# UMAP with clusters labeled with number
DimPlot(dat, 
        label = TRUE)
```

## Subset data 5 - 6 hr embryos

```{r, eval = FALSE}
# Subset the data to between 5 and 6 hours according to the NNv1 model
# Remove the old features in the dat object from the dat_5
# Slim down Seurat object so it doesn't carry over the dat from all data
dat_5 <- DietSeurat(subset(dat, NNv1_age > 5 & NNv1_age < 6))
```

### Make new UMAP

Need to re-scale and re-cluster etc. when subsetted to create a new UMAP. See the functions below.

```{r, eval = FALSE}
# Scales and centers the data of just the subset dat_5
dat_5 <- ScaleData(FindVariableFeatures(NormalizeData(dat_5), 
                                        selection.method = 'vst'))

# Returns PCA -- uses pc.genes 2000 variable features -- need to look into 
#   the pc.genes and VariableFeatures more
# Output in dat_5@reductions$pca
dat_5 <- RunPCA(dat_5, 
                pc.genes = VariableFeatures(dat_5))

# Returns UMAP
# Output in dat_5@reductions$umap
dat_5 <- RunUMAP(dat_5, 
                 dims = 1:50, 
                 n.neighbors = 10, 
                 n.components = 2)

# Nearest-neighbor graph construction
# Output in dat_5@graphs$RNA_nn; dat_5@graphs$RNA_snn
dat_5 <- FindNeighbors(dat_5, 
                       reduction = "umap", 
                       dims = 1:2)

# Identify Clusters of cells -- need to calculate the K-nearest neighbors first
# Output in seurat_clusters metadata
dat_5 <- FindClusters(dat_5, 
                      resolution = 0.08)
```

### Plot new UMAP

```{r, eval = FALSE, echo = FALSE}
# Save dat_5
saveRDS(dat_5, here::here("calderon/data/dat_5.rds"))
```

```{r, echo = FALSE}
# Read in dat_5
dat_5 <- readRDS(here::here("calderon/data/dat_5.rds"))
```

```{r}
DimPlot(dat_5)
```

## Find all marker genes of each cluster

```{r, eval = FALSE}
# Find the markers for each cluster
dat_5_markers <- FindAllMarkers(dat_5,
                                only.pos = TRUE, 
                                min.pct = 0.25, 
                                logfc.threshold = 0.25)
# Save just the top 10 markers
top_10_markers <- dat_5_markers %>%
    group_by(cluster) %>%
    slice_max(n = 10, 
              order_by = avg_log2FC)
```

```{r, eval = FALSE, echo = FALSE}
saveRDS(top_10_markers, here::here("calderon/data/top_10_markers.rds"))
```

```{r, echo = FALSE}
top_10_markers <- readRDS(here::here("calderon/data/top_10_markers.rds"))
```

```{r}
# Print out the top 2 markers just to look at
top_10_markers %>%
  slice_max(n = 2, 
            order_by = avg_log2FC) %>%
  select(gene, everything())
```

# **Differential expression analysis**

Trying differential expression in 5 hr embryos vs. 10 hr embryos.

## Integrate the data sets

```{r, eval = FALSE}
# Create data subset and clear other info
dat_5 <- DietSeurat(subset(dat, NNv1_age > 5.45 & NNv1_age < 5.55))
dat_10 <- DietSeurat(subset(dat, NNv1_age > 10.1 & NNv1_age < 10.9))

# Perform integration
dat_anchors <- FindIntegrationAnchors(object.list = list(dat_5, dat_10), 
                                      dims = 1:20)
dat_comb <- IntegrateData(anchorset = dat_anchors,
                          dims = 1:20)
```

## Perform an integrated analysis

```{r, eval = FALSE}
# Set default to integrated
DefaultAssay(dat_comb) <- "integrated"

# Run the standard workflow for visualization and clustering
dat_comb <- ScaleData(dat_comb, verbose = FALSE)
dat_comb <- RunPCA(dat_comb, npcs = 30, verbose = FALSE)

# t-SNE and Clustering
dat_comb <- RunUMAP(dat_comb, reduction = "pca", dims = 1:20)
dat_comb <- FindNeighbors(dat_comb, reduction = "pca", dims = 1:20)
dat_comb <- FindClusters(dat_comb, resolution = 0.5)

# Split the data by the two time windows for plotting
# Not sure if this info exists somewhere else?
dat_comb@meta.data <- dat_comb@meta.data %>%
  mutate(time = ifelse(NNv1_age < 6, "5", "10"))
```

```{r, eval = FALSE, echo = FALSE}
saveRDS(dat_comb, here::here("calderon/data/dat_comb.rds"))
```

```{r, echo = FALSE}
dat_comb <- readRDS(here::here("calderon/data/dat_comb.rds"))
```

```{r}
DimPlot(dat_comb,
        group.by = "time")

DimPlot(dat_comb,
        label = TRUE)

DimPlot(dat_comb,
        split.by = "time")
```

### Counts

```{r}
# Number of cells per time window
dat_comb@meta.data %>% 
  dplyr::count(time)

# Number of cells in cluster
dat_comb@meta.data %>%
  dplyr::count(seurat_clusters)

# Number of cells per time window and cluster
dat_comb@meta.data %>% 
  dplyr::count(time, seurat_clusters) %>%
  pivot_wider(values_from = n,
              names_from = time)
```

```{r}
# Plot the number of cells in each cluster
dat_comb@meta.data %>% 
  dplyr::count(time, seurat_clusters) %>%
  mutate(time = fct_relevel(time, c("5", "10"))) %>%
  ggplot() +
  geom_col(aes(x = seurat_clusters,
               y = n,
               fill = time),
           position = "dodge") +
  scale_fill_manual(values = c("#888888", "#444444")) +
  theme_minimal()
```


## Conserved expression between clusters

```{r, eval = FALSE}
# Set default assay back to RNA
DefaultAssay(dat_comb) <- "RNA"

# Find the conserved markers between conditions ----

# Initialize list to save markers for each cluster comparison
markers_all <- list()

# Loop through all clusters to find markers in each cluster
for (i in levels(dat_comb$seurat_clusters)) {
  print(paste("begin", i))
  # Find the conserved markers between 5 hr and 10 hr embryos
  marker <- FindConservedMarkers(dat_comb,
                                 ident.1 = i,
                                 grouping.var = "time",
                                 verbose = FALSE)
  # Save markers in the list
  markers_all[[i]] <- marker %>% rownames_to_column("gene")
  print(paste("end", i))
}

# Combine into a single data_frame
dat_comb_cluster_con <- bind_rows(markers_all, .id = "cluster")
```

```{r, eval = FALSE, echo = FALSE}
# Save dat_comb_cluster_con
saveRDS(dat_comb_cluster_con, 
        here::here("calderon/data/dat_comb_cluster_con_5_10.rds"))
```

```{r, echo = FALSE}
# Save dat_comb_cluster_con
dat_comb_cluster_con <- 
  readRDS(here::here("calderon/data/dat_comb_cluster_con_5_10.rds"))
```

```{r}
# Count the number of conserved genes per cluster
dat_comb_cluster_con %>%
  group_by(cluster) %>%
  tally() %>%
  arrange(desc(n))
```

## Visualize conserved expression

### UMAP

```{r}
# List of the top gene in each cluster
top_1 <- dat_comb_cluster_con %>%
  group_by(cluster) %>%
  slice_min(n = 1, minimump_p_val, with_ties = FALSE)

top_2 <- dat_comb_cluster_con %>%
  group_by(cluster) %>%
  slice_min(n = 2, minimump_p_val, with_ties = FALSE)

# Reset the default assay to RNA for plotting purposes
DefaultAssay(dat_comb) <- "RNA"

FeaturePlot(dat_comb,
            features = top_1$gene[1:2],
            split.by = "time", 
            max.cutoff = 3)
```

### Dot Plot between clusters

```{r}
DotPlot(dat_comb, 
        features = top_1$gene, 
        cols = c("blue", "red"), 
        dot.scale = 8, 
    split.by = "time") +
  RotatedAxis()
```

### Violin Plot

```{r}
VlnPlot(dat_comb, 
        top_1$gene[4:6], 
        split.by = "time", 
        group.by = "seurat_clusters",
        stack = TRUE,
        flip = TRUE)
```


## Differential Expression

```{r}
# Set identity to time window
Idents(dat_comb) <- dat_comb$time

# Identify DEGs
degs <- FindMarkers(dat_comb, 
                    ident.1 = "5", ident.2 = "10")
```

```{r}
VlnPlot(dat_comb, 
        rownames(degs)[1:3], 
        split.by = "time", 
        group.by = "seurat_clusters",
        stack = TRUE,
        flip = TRUE)
```

```{r}
DotPlot(dat_comb, 
        features = rownames(degs)[1:25], 
        cols = c("blue", "red"), 
        dot.scale = 8, 
    split.by = "time",
    group.by = "seurat_clusters") +
  RotatedAxis()
```

```{r}
FeaturePlot(dat_comb,
            features = rownames(degs)[1:4],
            split.by = "time", 
            max.cutoff = 3)
```

### Subsampling for DEGs

```{r, eval = FALSE}
# Create a number of cells to randomly subset
sub_n <- c(500, 1000, 2000, 4000, 8000, 12000, 15772)

# Empty tibble to populate
deg <- tibble()

# Loop through subsamples
for (n in 1:length(sub_n)) {
  
  # Print out at start of loop
  print(paste("Begin", n))
  
  # Subset 
  dat_comb_sub <- DietSeurat(subset(dat_comb, 
                         cell %in% sample(dat_comb$cell, sub_n[n])))
  
  # Redo scaling and stuff before degs
  dat_comb_sub <- ScaleData(dat_comb_sub, verbose = FALSE)
  dat_comb_sub <- FindVariableFeatures(dat_comb_sub)
  dat_comb_sub <- RunPCA(dat_comb_sub, npcs = 30, verbose = FALSE)
  dat_comb_sub <- RunUMAP(dat_comb_sub, reduction = "pca", dims = 1:20)
  dat_comb_sub <- FindNeighbors(dat_comb_sub, reduction = "pca", dims = 1:20)
  dat_comb_sub <- FindClusters(dat_comb_sub, resolution = 0.5)
  
  # DEGs
  Idents(dat_comb_sub) <- dat_comb_sub$time
  degs <- FindMarkers(dat_comb_sub, ident.1 = "5", ident.2 = "10")
  
  # Add to DEG object
  deg <- bind_rows(deg,  
                   degs %>% 
                     rownames_to_column("gene") %>% 
                     mutate(sub_n = sub_n[n]))
  
  # Print out at end of loop
  print(paste("End", n))
}

# Save deg
saveRDS(deg, here::here("calderon/data/tso_sub_n_deg.rds"))

```

```{r, echo = FALSE}
# Read in DEGs from sub samples 
deg <- readRDS(here::here("calderon/data/tso_sub_n_deg.rds"))
```

```{r}
# Count of total number of genes per subsample
deg %>%
  group_by(sub_n) %>%
  tally()

# Count number of significant DEGs
deg %>%
  group_by(sub_n) %>%
  mutate(sig = p_val_adj < 0.05) %>%
  group_by(sub_n, sig) %>%
  tally()

# Quickly plot number of DEGs per subsample
deg %>%
  group_by(sub_n) %>%
  filter(p_val_adj < 0.05) %>%
  tally() %>%
  ggplot(aes(x = sub_n,
                y = n)) +
  geom_line(linetype = 2) +
  geom_point(size = 2) +
  labs(y = "Number of differentially expressed genes",
       x = "Number of cells in subsample") +
  theme_minimal()

# Quickly plot number of genes per subsample
deg %>%
  group_by(sub_n) %>%
  tally() %>%
  ggplot(aes(x = sub_n,
                y = n)) +
  geom_line(linetype = 2) +
  geom_point(size = 2) +
  labs(y = "Number of genes",
       x = "Number of cells in subsample") +
  theme_minimal()
```


## Annotation of cell types and tissues

> For cluster annotation, we used the Berkeley Drosophila Genome Project (BDGP) database,
which includes gene expression patterns of approximately 8600 genes in drosophila staged
embryos as detected by in situ hybridization (20, 21, 58). The BDGP database gives a stagespecific expression pattern (“term”) for each tested gene during embryogenesis. We used Fisher’s
test to look for enrichment of BDGP gene expression terms in each cluster’s marker genes. Top
ten terms per cluster were examined. To pick a specific term out of the top ten, we further examined
the BDGP terms of the top 20 marker genes for each cluster.

However, there do seem to be resources out there to automate the annotation process. For example, [`SingleR`](http://bioconductor.org/books/release/SingleRBook/).

### Annotations from Calderon RNA-Seq data

```{r}
# This meta data has the annotations for each cell
rna_meta <- readRDS(here::here("calderon/data/rna_meta.rds"))
colnames(rna_meta)

# Added information in the rna_meta data
setdiff(colnames(rna_meta), colnames(dat@meta.data))

# List of the manual annotations
unique(rna_meta$germ_layer)
unique(rna_meta$manual_annot)
```

## `SingleR` for annotation of cells

```{r}
# Establish a reference object from the Calderon data

# Need to create a SummarizedExperiment object from dat object
# Add the rna_meta annotations from the Calderon data
dat@meta.data$manual_annot <- rna_meta$manual_annot
dat@meta.data$germ_layer <- str_replace_all(rna_meta$germ_layer, 
                                            "^$", "unknown") 
```

```{r, eval = FALSE}
# Create reference data set -- use just 7 hour embryos to annotate 
ref_sce <- as.SingleCellExperiment(DietSeurat(subset(dat, NNv1_age > 7 & 
                                                       NNv1_age < 8)))
ref_sce <- scuttle::logNormCounts(ref_sce)
```


```{r, eval = FALSE}
# Convert to a single cell experiment object for annotations
sce_comb <- as.SingleCellExperiment(DietSeurat(dat_comb))

# Create logNormCounts for data
sce_comb <- scuttle::logNormCounts(sce_comb)
```

Create annotation labels for each cell with `SingleR`.

```{r, eval = FALSE}
# Run SingleR to create annotation labels for each cell
annot <- SingleR(test = sce_comb,
                 assay.type.test = 1,
                 ref = ref_sce,
                 labels = ref_sce$manual_annot)
```

```{r, echo = FALSE}
# SingleR took ~ 1 hr to run so saved this as an annot file to load later
# Should consider scheduling this through slurm next time
# saveRDS(annot, here::here("calderon/data/tso_annot_sce_comb.rds"))

# Load annot data
annot <- readRDS(here::here("calderon/data/tso_annot_sce_comb.rds"))
```

### Germ layer annotation

```{r, eval = FALSE}
# Run SingleR to create annotation labels for each cell
annot_germ <- SingleR(test = sce_comb,
                      assay.type.test = 1,
                      ref = ref_sce,
                      labels = ref_sce$germ_layer)
```

```{r, echo = FALSE}
# SingleR took ~ 1 hr to run so saved this as an annot file to load later
saveRDS(annot_germ, here::here("calderon/data/tso_annot_germ_sce_comb.rds"))

# Load annot data
annot_germ <- readRDS(here::here("calderon/data/tso_annot_germ_sce_comb.rds"))
```

### Check annotations

```{r}
# Annotation diagnostics
plotScoreHeatmap(annot)
plotScoreHeatmap(annot_germ)
```

```{r, eval = FALSE}
# Set the annotations back in the Seurat object for later
dat_comb@meta.data$annot <- annot$pruned.labels
dat_comb@meta.data$annot_germ <- annot_germ$pruned.labels
```

```{r}
# Count the number of cells in each annotation
dat_comb@meta.data %>%
  group_by(time, annot) %>%
  tally() %>%
  pivot_wider(values_from = n,
              names_from = time) %>%
  arrange(desc(`5`)) %>%
  select(annot, `5`, `10`) %>%
  print(n = 37)


# Count the number of cells in each annotation
dat_comb@meta.data %>%
  group_by(time, annot_germ) %>%
  tally() %>%
  pivot_wider(values_from = n,
              names_from = time) %>%
  arrange(desc(`5`)) %>%
  select(annot_germ, `5`, `10`)
```

```{r}
# Plot the number of cells in each annotation
dat_comb@meta.data %>%
  group_by(time, annot) %>%
  tally() %>%
  pivot_wider(values_from = n,
              names_from = time) %>%
  arrange(desc(`5`)) %>%
  select(annot, `5`, `10`) %>%
  head(20) %>%
  pivot_longer(names_to = "time", 
               cols = c(`5`, `10`)) %>%
  #mutate(time = fct_relevel(time, c("5", "10"))) %>%
  ggplot() +
  geom_col(aes(x = annot,
               y = value,
               fill = time),
           position = "dodge") +
  scale_fill_manual(values = c("#444444", "#888888")) +
  theme_minimal() +
  coord_flip()
```


```{r}
# Plot all the annotations on a UMAP for 5 and 10 hour embryos
DimPlot(dat_comb,
        group.by = "annot",
        split.by = "time")


# Plot all the annotations on a UMAP for 5 and 10 hour embryos
DimPlot(dat_comb,
        group.by = "annot_germ",
        split.by = "time")
```

#### Percent matching at 5 hrs

```{r}
# Check to make sure that the cells in the vector are aligned correctly
sum(rownames(subset(dat, NNv1_age > 5.45 & NNv1_age < 5.55)@meta.data) != 
      rownames(subset(dat_comb, time == "5")@meta.data))

# Find the number of matches
n_match <- sum(subset(dat, 
                      NNv1_age > 5.45 & 
                        NNv1_age < 5.55)@meta.data$manual_annot ==
                 subset(dat_comb, time == "5")@meta.data$annot, na.rm = TRUE)

# Number of total cells 
n_cells <- ncol(subset(dat, NNv1_age > 5.45 & NNv1_age < 5.55))

# Percent true match to manual annotation
(n_match/n_cells)*100
```

```{r}
# Check to make sure that the cells in the vector are aligned correctly
sum(rownames(subset(dat, NNv1_age > 5.45 & NNv1_age < 5.55)@meta.data) != 
      rownames(subset(dat_comb, time == "5")@meta.data))

# Find the number of matches
n_match <- sum(subset(dat, 
                      NNv1_age > 5.45 & 
                        NNv1_age < 5.55)@meta.data$germ_layer ==
                 subset(dat_comb, time == "5")@meta.data$annot_germ, 
               na.rm = TRUE)

# Number of total cells 
n_cells <- ncol(subset(dat, NNv1_age > 5.45 & NNv1_age < 5.55))

# Percent true match to manual annotation
(n_match/n_cells)*100
```

#### Percent matching at 10 hrs

```{r}
# Check to make sure that the cells in the vector are aligned correctly
sum(rownames(subset(dat, NNv1_age > 10.1 & NNv1_age < 10.9)@meta.data) != 
      rownames(subset(dat_comb, time == "10")@meta.data))

# Find the number of matches
n_match <- sum(subset(dat, 
                      NNv1_age > 10.1 & 
                        NNv1_age < 10.9)@meta.data$germ_layer ==
                 subset(dat_comb, time == "10")@meta.data$annot_germ, 
               na.rm = TRUE)

# Number of total cells 
n_cells <- ncol(subset(dat, NNv1_age > 10.1 & NNv1_age < 10.9))

# Percent true match to manual annotation
(n_match/n_cells)*100
```

Really low match rate. Need to figure out what is going on here. Might be that there are annotation categories that are present in some but not others. See below. But there must be something else going on too. This is annoying. It also splits up the clusters and doesn't annotate per cluster it only annotates per cell.



Is there a way to annotate per specific cluster instead of a per cell annotation like here?


```{r}
# Labels present in manual annotation
unique(subset(dat,NNv1_age > 10.1 & NNv1_age < 10.9)@meta.data$manual_annot)
# Labels present in SingleR annotation
unique(subset(dat_comb, time == "10")@meta.data$annot)

# Labels that are only present in the manual annotation
setdiff(unique(subset(dat,NNv1_age > 10.1 & 
                        NNv1_age < 10.9)@meta.data$manual_annot),
        unique(subset(dat_comb, time == "10")@meta.data$annot))

# Labels that are only present in the SingleR annotation
setdiff(unique(subset(dat_comb, time == "10")@meta.data$annot),
        unique(subset(dat,NNv1_age > 10.1 & 
                        NNv1_age < 10.9)@meta.data$manual_annot))
```

# SCENIC

SCENIC (**S**ingle-**C**ell r**E**gulatory **N**etwork ***I**nference and **C**lustering)


Downloaded the SCENIC database [`dm6-5kb-upstream-full-tx-11species.mc8nr.feather`](https://resources.aertslab.org/cistarget/databases/old/drosophila_melanogaster/dm6/flybase_r6.02/mc8nr/gene_based/dm6-5kb-upstream-full-tx-11species.mc8nr.feather), which is the old database. The new one wasn't working per this [GitHub issue](https://github.com/aertslab/SCENIC/issues/334).

```{r, eval = FALSE}
# Load library
require(SCENIC)
library(SCopeLoomR)

# Load data
dat_comb <- readRDS(here::here("calderon/data/dat_comb.rds"))
Idents(dat_comb) <- "cluster"
DefaultAssay(dat_comb) <- "RNA"
dat_comb <- NormalizeData(dat_comb)

# Filtering genes for calculating time
exprMat <- as.matrix(dat_comb@assays$RNA@data)
cellInfo <- dat_comb@meta.data

# Set options
scenicOptions <- initializeScenic(org = "dmel",
                                  dbDir = here::here("calderon/dbDir"),
                                  datasetTitle = "5 hr vs. 10 hr combined",
                                  nCores = 10)

# Save the scenicOptions being used for later reference --
saveRDS(scenicOptions, 
        file = here::here("calderon/scenic/int/scenicOptions.rds"))

# This sorta already exists? Do I really need to redo it?
cellInfo$nGene <- colSums(exprMat>0)
cellInfo <- data.frame(cellInfo)
cbind(table(cellInfo$annot))

# Save the cellInfo being used for later reference --
saveRDS(cellInfo, 
        here::here("calderon/scenic/int/cellInfo.rds"))


# Co-expression network -----

# Filter out genes bases on min number of 
genesKept <- geneFiltering(exprMat, scenicOptions)
exprMat_filtered <- exprMat[genesKept, ]

# Run the correlation -- stored in "int/1.2_corrMat.Rds"
runCorrelation(exprMat_filtered, scenicOptions)

# Log2 expression of the filtered expression matrix
exprMat_filtered_log <- log2(exprMat_filtered + 1) 
# Save exprMat_filtered_log for later
saveRDS(exprMat_filtered_log, 
        here::here("calderon/scenic/int/exprMat_filtered_log.rds"))

# ------------------------------------------------------------------------------
# GENIE3 -- recovers the gene regulatory network from the expression data ------
# ------------------------------------------------------------------------------

# Load data
scenicOptions <- readRDS(here::here("calderon/scenic/int/scenicOptions.rds"))
exprMat_filtered_log <- readRDS(here::here("calderon/scenic/int/exprMat_filtered_log.rds"))

# Run GENIE3
runGenie3(exprMat_filtered_log, scenicOptions)

# After Genie3
aucellApp <- plotTsne_AUCellApp(scenicOptions, exprMat_filtered_log)

library(SCENIC)
scenicOptions <- readRDS("calderon/scenic/int/scenicOptions.rds")
scenicOptions@settings$verbose <- TRUE
scenicOptions@settings$nCores <- 10
scenicOptions@settings$seed <- 123

# For a very quick run: 
# coexMethod=c("top5perTarget")
scenicOptions@settings$dbs <- scenicOptions@settings$dbs["10kb"] # For toy run
# save...

setwd(here::here("calderon/scenic"))
scenicOptions <- runSCENIC_1_coexNetwork2modules(scenicOptions)

scenicOptions <- runSCENIC_2_createRegulons(scenicOptions, coexMethod=c("top5perTarget")) #** Only for toy run!!
scenicOptions <- runSCENIC_3_scoreCells(scenicOptions, exprMat_log)
saveRDS(scenicOptions, file="int/scenicOptions.Rds") # To save status

```











# ------------------------------------------------------------------------------




# **ATAC-Seq data**

```{r}
atac <- readRDS(
  here::here("calderon/data/exp1_hrs03-07_b1_gene_activity_counts.rds"))

atac <- readRDS(
  here::here("calderon/data/fly.new.04-06_seurat_filtered_processed.rds"))
```

## Data structure of Seurat object

```{r}
# Class
class(atac)

# Structure of data
str(atac)

# Peak at the data
head(atac)

# Print dimensions
# Rows = genes; columns = cells
dim(atac)
```

## Metadata per cell
```{r}
# Metadata
atac@assays
```

```{r}
# 

# Extract gene annotations from EnsDb
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v75) 
```





Other things to try:

- Try RNA-Seq quality control filtering etc.
- See the number of genes that meet the 0.02 count per per cell for differential expression per Joe Boyd


